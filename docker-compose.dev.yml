# ==================== Режим development ====================

# ---------- описываем сервисы (1 сервис = 1 контейнер): ----------
services:
  # ---------- первый сервис - библиотека: ----------
  library:
    build:
      context: ./library # где искать Dockerfile для сборки образа счётчика
      dockerfile: docker/Dockerfile.dev # нестандартное имя для Dockerfile
    depends_on:
      - counter # зависимость от сервиса-счётчика
    environment:
      PORT: 3000 # переменная окружения "PORT" -> сервис запустится на порту 3000
      MICROSERVICE_URL: http://counter:4000 # переменная окружения -> вместо http://localhost:4000
    ports:
      - 3000:3000 # прокидываем порт для связи хоста с контейнером
    volumes:
      - ./library:/app # монтируем код с хоста в контейнер, чтобы сразу видеть изменения
      - /app/node_modules # чтобы node_modules оставались контейнерными

  # ---------- второй сервис - счётчик: ----------
  counter:
    build:
      context: ./counter # где искать Dockerfile для сборки образа счётчика
      dockerfile: Dockerfile.dev # нестандартное имя для Dockerfile
    depends_on:
      - redis # зависимость от базы данных
    environment:
      PORT: 4000 # переменная окружения "PORT" -> сервис запустится на порту 4000
      REDIS_URL: redis://redis:6379 # переменная окружения -> вместо redis://localhost:6379
    ports:
      - 4000:4000 # прокидываем порт для связи хоста с контейнером
    volumes:
      - ./counter:/app # монтируем код с хоста в контейнер, чтобы сразу видеть изменения
      - /app/node_modules # чтобы node_modules оставались контейнерными

  # ---------- третий сервис - база данных: ----------
  redis:
    image: redis # загружаем готовый образ с тегом :latest из реестра hub.docker.com
    ports:
      - 6379:6379 # прокидываем порт для связи хоста с контейнером
    volumes:
      - redis-db:/data # том для сохранения данных

# ---------- Docker volumes: ----------
volumes:
  redis-db: # создаём именованный docker-том `${название-корневой-папки}_redis-db`
